# 00
## 엔티티 설계
![image](https://user-images.githubusercontent.com/68311318/179228174-47306548-1086-405b-afa5-253876665f50.png)

- Address
  - 임베디드 타입(내장 타입)
  - 값 타입
- OrderItem
  - 다대다 관계의 연결 테이블
  - 인공키 존재
- Category 와 Item
  - 다대다 관계
  - ManyToMany
- Category
  - parent category , child List 의 계층 구조

## 테이블 설계
![image](https://user-images.githubusercontent.com/68311318/179229851-a280a93b-80b9-4f37-99dd-d9146906d896.png)
- Orders
  - 이름에 s 가 붙은 이유는 그냥 order by 때문에
- Item
  - 3가지 방법 중 가장 단순한 싱글 테이블 전략 사용
    - 컬럼 다 섞여 있으니 단점이긴 한데 성능이 잘 나옴
- 일대일 관계
  - 두 테이블 중 아무대나 FK 둬도 됨
- 다대다가 2개임
  - 하나는 인공키
    - 연결 테이블의 엔티티를 만들지 않아도된다
    - 
  - 하나는 복합키
    - 연결 테이블에 해당하는 엔티티 클래스를 만든다
    - 그런다음에는 다대일 관계 매핑하는 것과 차이가 없음

- Q. fk 를 꼭 걸어야되나요
  - A. 시스템 마다 다르다. 실시간 트래픽이 엄청 중요하고 정합성 보다는 잘 서비스 되는게 유연한게 중요하면  
  fk 빼고 인덱스만 잘 잡아주면 된다. 근데 돈과 관련된 엄청 중요한 거고 하면 fk 를 걸어주는 것에 대해  
  진지하게 고민할 필요가 있음
  - A. https://dataedo.com/blog/why-there-are-no-foreign-keys-in-your-database-referential-integrity-checks

## 엔티티 설계시 주의점
### 모든 연관관계는 지연로딩으로 설정!
  - 즉시로딩(EAGER)은 예측이 어렵고, 어떤 SQL 이 실행될지 **추적**하기 어렵다
    - 최악의 경우, 모든 관계가 EAGER 로 돼있으면, 하나만 가져오면 모든 테이블을 다 끌고 온다
    1. 일단 모든 것을 LAZY 로 세팅해놓고, 문맥에 따라서 원하는 연관된 엔티티를 몇개만 찝어서 가져올 수 있다 주로 이걸 fetch join 이라한다. 
    2. 엔티티 그래프 기능을 사용해도 가능하다
  - **특히 JPQL 을 실행할 때 N+1 문제가 자주 발생한다!**
    - 예를 들면 우리가 의도한 sql 이 select * from order 이면 우리는 JPQL 을 select o from order o; 로 쓴다
      - 그럼 우릐 의도 대로 select * from order 해서 일단 Order 만 가져오는데, 가져오고 보니까 EAGER 로 되있는거다 그럼 쿼리 날라감
      - 만약 select * from order 쿼리 한번 날려서 order 을 100개 가져왔다면, 100 개 쿼리가 또 날라가는거다! 그래서 이를 N + 1 문제라 함(순서상 1 + N 이 더 맞는거같은데)
    - EAGER 의 뜻은 **단순히 join 한다는게 아니라**, 내가 Order 를 조회하는 시점에 어떻게든 Member 를 꼭 같이 조회 하겠다는 뜻임 그래서 난리가 남
  - 실무에서 모든 연관관계는 지연로딩(LAZY)으로 설정해야한다
  - 조인하고 싶다면, 대안은 이렇다 : 연관된 엔티티를 함께 DB 에서 조회해야하면 **fetch join** 또는 **엔티티 그래프** 기능을 사용한다
  - 이슈
    - LAZY 로딩이 트랜잭션 밖에서는 안되는 이슈가 있다 그래서 LAZY 로딩 익셉션 나서 EAGER 로 바꾸는 사람들이 있는데
    - 이것도 다 대안이 있다 트랜잭션을 좀 빨리 가져온다던가 상황에 따라서는 OSIV 를 쓴다거나 다 해결책이 있음 궁극적인 해결책은 거의 FETCH JOIN 으로 해결이 됨

### 컬렉션은 필드에서 초기화하자
- 이게 베스트 프랙티스임
- 일단은 null 문제에서 안전하다
  - 근데 이건 중요한게 아니고
- 중요
  - 하이버네이트가 엔티티를 영속화하는 순간, 컬렉션을 한번 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다(영속성 컨텍스트에서 이 컬렉션을 관리해야 하기 때문(컬렉션이 변경되면 **추적**해야하기때문)).  
  만약 getOrders() 처럼 임의의 메서드에서 컬렉션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있따. 따라서 필드레벨에서 생성하는 것이 가장 안전하고 코드도 간결하다
  - 그니까 필드에서 초기화한 컬렉션을 가급적이면 변경하지말자 그냥 절대 바꾸지 말자 있는거를 그대로 쓰자 그게 제일 안전하기 때문

### cascade all
- persist 전파
  - 원래 기본적으로 모든 엔티티는 각각 persist 하는 것이 기본이지만 이렇게 하면 편리
- delete? 전파
- 등?

### 연관관계 편의 메서드
- 양방향 세팅할때 사용하면 좋다(물론 db 에 넣을때는 한쪽만 세팅해주면 되지만 양방향으로 하면 편리하니까)
  - 다른 경우에도 사용하나
- 목적: 누락 방지
- 연관관계 편의 메서드의 위치는 어디가 좋냐면, 핵심적으로 뭔가 컨트롤 하는쪽이 들고있는 것이 좋다

- TODO: 주의점 강의 나오는 코드 반영 안했음